# Copyright (C) 2023 <FacuFalcone - CaidevOficial>
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from tkinter.messagebox import showinfo as alert

import pandas as pd
import customtkinter
from tkinter import *
import pygame.mixer as mixer 


class App(customtkinter.CTk):
    __dataframe = pd.DataFrame()
    __dataset_values = [
        "sea_procurement_196220_in", "sea_sales_208868_in",
        "sea_sales_109534_in", "mssfinsapbw_109534_in"
    ]
    __file_paths = {
        "source": './source_pbi_fields.xlsx',
        "destiny": './',
        "sound_error": "./assets/sound/",
        "sound_success": "./assets/sound/"
    }
    __template = """\
    let
        Source = GoogleBigQuery.Database([BillingProject = ProjectID, UseStorageApi = false]),
        Navigation = Source{[Name = DatalakeID]}[Data],
        #"Navigation 1" = Navigation{[Name = "DATASET_NAME", Kind = "Schema"]}[Data],
        #"Navigation 2" = #"Navigation 1"{[Name = "TABLE_NAME", Kind = "Table"]}[Data],
        #"Renamed columns" = Table.RenameColumns(#"Navigation 2", {})
    in
        #"Renamed columns"
    """
    __table_name: str = None
    __dataset_name: str = None
    __full_path: str = None
    
    
    def __init__(self):
        super().__init__()

        # configure window
        self.title("SEA Power BI Script Creator")
        self.__frame_main = customtkinter.CTkFrame(self, corner_radius=0, fg_color="transparent")
        self.__frame_main.grid(row=0, column = 0, padx=20, pady=5, columnspan=4, rowspan = 2, sticky="we")
        
        self.__frame_input = customtkinter.CTkFrame(self.__frame_main, corner_radius=0, fg_color="transparent")
        self.__frame_input.grid(row=0, column = 0, padx=20, pady=5, columnspan=2, rowspan = 2, sticky="nsew")
        
        self.__frame = customtkinter.CTkFrame(self.__frame_main, corner_radius=0, fg_color="transparent")
        self.__frame.grid(row=4, padx=20, pady=4, columnspan=5, rowspan = 3, sticky="nsew")
        
        self.__txt_table_name = customtkinter.CTkEntry(master=self.__frame_input, height = 14, placeholder_text="Table Name")
        self.__txt_table_name.grid(row=1, column=0, padx=20, pady=5)

        self.__combobox_dataset_name = customtkinter.CTkComboBox(master=self.__frame_input, height = 14, width=199, values=self.__dataset_values)
        self.__combobox_dataset_name.grid(row=1, column=1, columnspan=2, padx=10, pady=(5, 5))

        self.__btn_add = customtkinter.CTkButton(master=self.__frame_input, height = 20, text="Create Script", command=self.bttn_create_on_click)
        self.__btn_add.grid(row=2, padx=20, pady=5, columnspan=2, sticky="ew")
    
    def __open_file(self) -> None:
        """
        This function reads an Excel file and returns a pandas DataFrame, or raises an error if the file
        cannot be loaded.
        
        :param path: The path parameter is a string that represents the file path of the Excel file that
        needs to be loaded into a pandas DataFrame
        :type path: str
        :return: a pandas DataFrame object.
        """
        try:
            self.__dataframe = pd.read_excel(self.__file_paths['source'])
        except Exception as e:
            self.__play_sound('sound_error')
            self.__SEA_messenger(f'Exception loading the file to make a dataframe: {e}', 'error')

    def __create_script(self) -> str:
        """
        This function takes a pandas DataFrame and a string template as inputs, replaces certain values in
        the template with values from the DataFrame, and returns the modified template as a string.
        
        :param df: A pandas DataFrame containing two columns: 'TECH_NAME' and 'FUNC_NAME'
        :type df: pd.DataFrame
        :param template: The template parameter is a string that represents a script template. It is used to
        create a new script by replacing certain placeholders with values from the input dataframe
        :type template: str
        :return: a string that is the updated version of the input template string with a message string
        that is generated by iterating over the rows of the input dataframe and replacing placeholders in
        the schema string with values from the dataframe. The message string is then inserted into the
        template string at a specific location.
        """
        message = ''
        first = True
        schema = '{"TECH", "FUNC"}'
        try:
            self.__table_name = self.__txt_table_name.get()
            self.__dataset_name = self.__combobox_dataset_name.get()
            for _, row in self.__dataframe.iterrows():
                replaced = schema.replace('TECH', row['TECH_NAME']).replace('FUNC', row['FUNC_NAME'])
                if first:
                    message += replaced
                    first = False
                else: message += f", {replaced}"
            self.__template = self.__template\
                .replace('(#"Navigation 2", {})', f'(#"Navigation 2", {{{message}}})')\
                .replace('DATASET_NAME', self.__dataset_name)\
                .replace('TABLE_NAME', self.__table_name)
            self.__SEA_messenger('Script Created!', 'info')
        except Exception as e:
            self.__play_sound('sound_error')
            self.__SEA_messenger(f'Exception getting the dataframe: {e}', 'error')
    
    def __create_txt_file(self):
        """
        This function creates a new text file at a specified path with a given template.
        
        :param path: The path parameter is a string that represents the file path where the text file will
        be created
        :type path: str
        :param template: The template parameter is a string that contains the content that will be written
        to the file
        :type template: str
        """
        try:
            self.__full_path = f"{self.__file_paths['destiny']}{self.__dataset_name}.{self.__table_name}.vba"
            with open(self.__full_path, 'w') as file:
                file.writelines(self.__template)
                self.__SEA_messenger(f"File created: {self.__full_path}", 'success')
                alert("Success", f"File created: {self.__full_path}")
        except Exception as e:
            self.__play_sound('sound_error')
            self.__SEA_messenger(f'Exception creating the file: {e}', 'error')
    
    def __SEA_messenger(self, message: str, message_type: str) -> None:
        """
        This is a Python function that prints messages with different colors and message types (error,
        success, and information).
        
        :param message: A string containing the message to be displayed
        :type message: str
        :param message_type: The type of message being passed, which can be "Error", "Success", or "Info"
        :type message_type: str
        """
        _b_red: str = '\033[41m'
        _b_green: str = '\033[42m'
        _b_blue: str = '\033[44m'
        _f_white: str = '\033[37m'
        _no_color: str = '\033[0m'
        message_type = message_type.strip().capitalize()
        match message_type:
            case 'Error':
                print(f'{_b_red}{_f_white}> Error: {message}{_no_color}')
            case 'Success':
                print(f'{_b_green}{_f_white}> Success: {message}{_no_color}')
            case 'Info':
                print(f'{_b_blue}{_f_white}> Information: {message}{_no_color}')
    
    def __play_sound(self, audio_name: str) -> None:
        sound = mixer.Sound(self.__file_paths[audio_name])
        mixer.Sound.play(sound)
    
    def bttn_create_on_click(self):
        mixer.init()
        
        self.__open_file()
        self.__create_script()
        self.__create_txt_file()
        


if __name__ == "__main__":
    app = App()
    app.mainloop()